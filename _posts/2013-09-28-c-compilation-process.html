---
layout: post
title: C++ Compilation Process
date: 2013-09-28 15:44:52.000000000 +05:30
type: post
published: true
status: publish
categories:
- CPP
tags: []
meta:
  _edit_last: '18160588'
  _publicize_job_id: '16454361262'
author:
  login: rameshnagaraj
  email: rameshn@live.in
  display_name: R@M3$H.N
  first_name: ''
  last_name: ''
---
<h2>The C++ compilation process</h2>
<p><img alt="C++ compilation process" src="{{ site.baseurl }}/assets/compile.png" align="right" /></p>
<p>Compiling a source code file in C++ is a four-step process. For example, if you have a C++ source code file named <code>prog1.cpp</code> and you execute the compile command</p>
<pre>   g++ -Wall -ansi -o prog1 prog1.cpp</pre>
<p>the compilation process looks like this:</p>
<ol>
<li>The C++ preprocessor copies the contents of the included header files into the source code file, generates macro code, and replaces symbolic constants defined using <code>#define</code> with their values.</li>
<li>The expanded source code file produced by the C++ preprocessor is compiled into the assembly language for the platform.</li>
<li>The assembler code generated by the compiler is assembled into the object code for the platform.</li>
<li>The object code file generated by the assembler is linked together with the object code files for any library functions used to produce an executable file.</li>
</ol>
<p>By using appropriate compiler options, we can stop this process at any stage.</p>
<ol>
<li>To stop the process after the preprocessor step, you can use the <code>-E</code> option:
<pre>   g++ -E prog1.cpp</pre>
<p>The expanded source code file will be printed on standard output (the screen by default); you can redirect the output to a file if you wish. Note that the expanded source code file is often incredibly large - a 20 line source code file can easily produce an expanded file of 20,000 lines or more, depending on which header files were included.</li>
<li>To stop the process after the compile step, you can use the <code>-S</code> option:
<pre>   g++ -Wall -ansi -S prog1.cpp</pre>
<p>By default, the assembler code for a source file named <em>filename.cpp</em> will be placed in a file named <em>filename.s</em>.</li>
<li>To stop the process after the assembly step, you can use the <code>-c</code> option:
<pre>   g++ -Wall -ansi -c prog1.cpp</pre>
<p>By default, the assembler code for a source file named <em>filename.cpp</em> will be placed in a file named <em>filename.o</em>.</li>
</ol>
<p>&nbsp;</p>
<p>We will briefly highlight key features of the C Compilation model here.</p>
<p><a name="fig:comp"></a> <img alt="" src="{{ site.baseurl }}/assets/cmodel.gif" /></p>
<p><b>Fig.The C Compilation Model</b></p>
<h2><a name="SECTION00321000000000000000"></a>The Preprocessor</h2>
<p>We will study this part of the compilation process in greater detail later.</p>
<p>However we need some basic information for some C programs.</p>
<p>The Preprocessor accepts source code as input and is responsible for</p>
<ul>
<li>removing comments</li>
<li>interpreting special <em>preprocessor directives</em> denoted by <tt>#</tt>.</li>
</ul>
<p>For example</p>
<ul>
<li><tt>#include</tt> -- includes contents of a named file. Files usually called <em>header</em> files. <em>e.g</em>
<ul>
<li><tt>#include &lt;math.h&gt;</tt> -- standard library maths file.</li>
<li><tt>#include &lt;stdio.h&gt;</tt> -- standard library I/O file</li>
</ul>
</li>
<li><tt>#define</tt> -- defines a symbolic name or constant. Macro substitution.
<ul>
<li><tt>#define MAX_ARRAY_SIZE 100</tt></li>
</ul>
</li>
</ul>
<h2><a name="SECTION00322000000000000000"></a>C Compiler</h2>
<p>The C compiler translates source to assembly code. The source code is received from the preprocessor.</p>
<h2><a name="SECTION00323000000000000000"></a>Assembler</h2>
<p>The assembler creates object code. On a UNIX system you may see files with a <tt>.o</tt> suffix (<tt>.OBJ</tt> on MSDOS) to indicate object code files.</p>
<h2><a name="SECTION00324000000000000000"></a>Link Editor</h2>
<p>If a source file references library functions or functions defined in other source files the <em>link editor</em> combines these functions (with <tt>main()</tt>) to create an executable file. External Variable references resolved here also.</p>
<p>&nbsp;</p>
<ul type="square">
<li><span style="font-family:Arial;font-size:medium;">Below are the stages that happen in order regardless of the operating system/compiler and graphically illustrated in Figure w.1.</span></li>
</ul>
<blockquote>
<ol>
<li><span style="font-family:Arial;font-size:medium;"><b>Preprocessing</b> is the first pass of any C compilation. It processes include-files, conditional compilation instructions and macros.</span></li>
<li><span style="font-family:Arial;font-size:medium;"><b>Compilation</b> is the second pass. It takes the output of the preprocessor, and the source code, and generates assembler source code.</span></li>
<li><span style="font-family:Arial;font-size:medium;"><b>Assembly</b> is the third stage of compilation. It takes the assembly source code and produces an assembly listing with offsets. The assembler output is stored in an object file.</span></li>
<li><span style="font-family:Arial;font-size:medium;"><b>Linking</b> is the final stage of compilation. It takes one or more object files or libraries as input and combines them to produce a single (usually executable) file. In doing so, it resolves references to external symbols, assigns final addresses to procedures/functions and variables, and revises code and data to reflect new addresses (a process called relocation).</span></li>
</ol>
</blockquote>
<p>&nbsp;</p>
<pre><code>ANSI C translation phases
                       =========================

          +-------------------------------------------------+
          | map physical characters to source character set |
          |     replace line terminators with newlines      |
          |           decode trigraph sequences             |
          +-------------------------------------------------+
                                   |
                                   V
               +---------------------------------------+
               | join lines along trailing backslashes |
               +---------------------------------------+
                                   |
                                   V
     +-------------------------------------------------------------+
     | decompose into preprocessing tokens and whitespace/comments |
     |                      strip comments                         |
     |                      retain newlines                        |
     +-------------------------------------------------------------+        
                                   |
                                   V
          +------------------------------------------------+
          | execute preprocessing directives/invoke macros |
          |              process included files            |
          +------------------------------------------------+
                                   |
                                   V
   +----------------------------------------------------------------+
   | decode escape sequences in character constants/string literals |
   +----------------------------------------------------------------+
                                   |
                                   V
                +--------------------------------------+
                | concatenate adjacent string literals |
                +--------------------------------------+
                                   |
                                   V
              +------------------------------------------+
              | convert preprocessing tokens to C tokens |
              |       analyze and translate tokens       |
              +------------------------------------------+
                                   |
                                   V
                    +-----------------------------+
                    | resolve external references |
                    |        link libraries       |
                    |      build program image    |
                    +-----------------------------+</code></pre>
<p>&nbsp;</p>
<p>The compilation of a C++ program involves several steps:</p>
<ol>
<li>Preprocessing: the preprocessor takes a C++ source code file and deals with the <code>#include</code>s,<code>#define</code>s and other preprocessor directives. The output of this step is a "pure" C++ file without pre-processor directives;</li>
<li>Compilation: the compiler takes the pre-processor's output and produces an object file from it.</li>
<li>Linking: the linker takes the object files produced by the compiler and produces either a library or an executable file.</li>
</ol>
<h1>Preprocessing</h1>
<p>The preprocessor handles the <em>preprocessor directives</em>, like <code>#include</code> and <code>#define</code>. It is agnostic of the syntax of C++, which is why it must be used with care.</p>
<p>It works on one C++ source file at a time by replacing <code>#include</code> directives with the content of the respective files (which is usually just declarations), doing replacement of macros (<code>#define</code>), and selecting different portions of text depending of <code>#if</code>, <code>#ifdef</code> and <code>#ifndef</code> directives.</p>
<p>The preprocessor is working on a stream of preprocessing token, and macro substitution is defined as replacing tokens by other tokens (the operator <code>##</code> allows to merge two tokens when it make sense).</p>
<p>After all this it produces a single output that is a stream of tokens resulting from the transformations described above. It also adds some special markers that tell the compiler where each line came from so that it can use those to produce sensible error messages.</p>
<p>Some errors can be produced at this stage with clever use of the <code>#if</code> and <code>#error</code> directives.</p>
<h1>Compilation</h1>
<p>The compilation step is performed on each output of the preprocessor. It involves parsing the C++ source code (now without any preprocessor directives) and, producing an object file. This object file contains the compiled code (in binary form) of the symbols defined in the input. Symbols in object files are referred to by name.</p>
<p>Object files can refer to symbols that are not defined. This is the case when you use a declaration, and don't provide a definition for it. The compiler doesn't mind this, and will happily produce the object file as long as the source code is well-formed.</p>
<p>Compilers usually let you stop compilation at this point. This is very useful because with it you can compile each source code file separately. The advantage this provides is that you don't need to recompile <em>everything</em> if you only change a single file.</p>
<p>The produced object files can be put in special archives called static libraries, for easier reusing later on.</p>
<p>It's at this stage the "regular" compiler errors, like syntax errors or failed overload resolution errors, are reported.</p>
<h1>Linking</h1>
<p>The linker is what produces the final compilation output from the object files the compiler produced. This output can be either a shared (or dynamic) library (and while the name is similar, they haven't got much in common with static libraries mentioned earlier) or an executable.</p>
<p>It links all the object files by replacing the references to undefined symbols contained within them with the correct addresses. Each of these symbols can be defined in other object files or in libraries. If they are defined in libraries other than the standard library, you need to tell the linker about them.</p>
<p>At this stage the most common errors are missing definitions or duplicate definitions. The former means that either the definitions don't exist (i.e. they are not written), or that the object files or libraries where they reside were not given to the linker. The latter is obvious: the same symbol was defined in two different object files or libraries.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>END</p>
