<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R@M3$H.N</title>
    <description>Tech Blog.
</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 12 Sep 2020 14:13:21 -0700</pubDate>
    <lastBuildDate>Sat, 12 Sep 2020 14:13:21 -0700</lastBuildDate>
    <generator>Jekyll v3.9.0</generator>
    
      <item>
        <title>Call Base class method through base class pointer pointing to derived class</title>
        <description>&lt;p&gt;class Base&lt;br /&gt;
{&lt;br /&gt;
  public:&lt;br /&gt;
    virtual void foo()&lt;br /&gt;
    {}&lt;br /&gt;
};&lt;/p&gt;
&lt;p&gt;class Derived: public Base&lt;br /&gt;
{&lt;br /&gt;
  public:&lt;br /&gt;
    virtual void foo()&lt;br /&gt;
    {}&lt;br /&gt;
};&lt;/p&gt;
&lt;p&gt;int main()&lt;br /&gt;
{&lt;br /&gt;
    Base *pBase = NULL;&lt;br /&gt;
    Base objBase;&lt;br /&gt;
    Derived objDerived;&lt;/p&gt;
&lt;p&gt;    pBase = &amp;amp;objDerived;&lt;br /&gt;
    pBase-&amp;gt;foo();&lt;/p&gt;
&lt;p&gt;    /*Here Derived class foo will be called, but i want this to call&lt;br /&gt;
    a base class foo. Is there any way for this to happen? i.e. through&lt;br /&gt;
    casting or something? */&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;You can do it through scope resolution operator ::&lt;/p&gt;
&lt;p&gt;Something like this:&lt;/p&gt;
&lt;p&gt;pBase-&amp;gt;Base::foo()&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Nov 2015 02:33:14 -0800</pubDate>
        <link>/cpp/2015/11/02/call-base-class-method-through-base-class-pointer-pointing-to-derived-class-2.html</link>
        <guid isPermaLink="true">/cpp/2015/11/02/call-base-class-method-through-base-class-pointer-pointing-to-derived-class-2.html</guid>
        
        
        <category>CPP</category>
        
      </item>
    
      <item>
        <title>Json &amp; XML Formating on Mac CommandLine</title>
        <description>&lt;p&gt; print formatted JSON, XML from osx command line&lt;br /&gt;
Working with various interfaces that output json or xml results in lots of situations where you have a single-line, unformatted output. Here's a quick way to format json, xml from the CLI.&lt;/p&gt;
&lt;p&gt;via the command line:&lt;/p&gt;
&lt;p&gt;format json&lt;/p&gt;
&lt;p&gt;cat unformatted.json | python -m json.tool&lt;br /&gt;
format json from clipboard&lt;/p&gt;
&lt;p&gt;pbpaste | python -m json.tool&lt;br /&gt;
format xml from clipboard&lt;/p&gt;
&lt;p&gt;pbpaste | xmllint --format -&lt;br /&gt;
xmllint is part of libxml2 and installed by default on OSX. Be aware that xmllint cleans up XML as well as formatting it, ocassionally modifying the output.&lt;br /&gt;
for all above examples, you can pipe back to the clipboard with | pbcopy at the end of the command, or output to a file with &amp;gt; output.json or &amp;gt; output.xml.&lt;/p&gt;
</description>
        <pubDate>Wed, 14 Oct 2015 03:27:01 -0700</pubDate>
        <link>/linux/2015/10/14/json-xml-formating-on-mac-commandline.html</link>
        <guid isPermaLink="true">/linux/2015/10/14/json-xml-formating-on-mac-commandline.html</guid>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>Constructing Bridges</title>
        <description>&lt;p&gt;Problem:&lt;br /&gt;
A River that cuts through a set of cities above and below it. Each city above the river is matched with a city below the river.&lt;br /&gt;
Construct as many Non-Crossing Bridges as possible.&lt;br /&gt;
Input:&lt;br /&gt;
Above Bank &amp;gt;&amp;gt; 7 4 3 6 2 1 5&lt;br /&gt;
Below Bank &amp;gt;&amp;gt; 5 3 2 4 6 1 7&lt;br /&gt;
are given in pairs: (7,5) (4,3) (3,2) (6,4) (2,6) (1,1) (5,7)&lt;br /&gt;
Output:&lt;br /&gt;
(1,1) (3,2) (4,3) (6,4) (7,5)&lt;/p&gt;
&lt;p&gt;Solution:&lt;br /&gt;
Its an Longest Increasing Sub-Sequence Dynamic programming Problem with O(N log N) solution.&lt;/p&gt;
&lt;p&gt;Above Bank &amp;gt;&amp;gt; 7 4 3 6 2 1 5&lt;br /&gt;
Below Bank &amp;gt;&amp;gt; 5 3 2 4 6 1 7&lt;br /&gt;
Pairs &amp;gt;&amp;gt; (7,5) (4,3) (3,2) (6,4) (2,6) (1,1) (5,7)&lt;/p&gt;
&lt;p&gt;Sort the pairs based on Lower Bank Cities as Below:&lt;br /&gt;
Above Bank &amp;gt;&amp;gt; 1 3 4 6 7 2 5&lt;br /&gt;
Below Bank &amp;gt;&amp;gt; 1 2 3 4 5 6 7&lt;/p&gt;
&lt;p&gt;Now the Problem reduces to finding the LIS from the Cities in Above Bank &amp;gt;&amp;gt; 1 3 4 6 7 2 5&lt;br /&gt;
which is 1 3 4 6 7&lt;/p&gt;
&lt;p&gt;So, the Output with corresponding Lower Bank Cities will be&lt;br /&gt;
(1,1) (3,2) (4,3) (6,4) (7,5)&lt;/p&gt;
&lt;p&gt;EDIT:&lt;br /&gt;
If we have the elements sorted by their Below Bank, then we can tell if two pairs are orderable by &amp;lt;=, by just looking at their positions in the Above Bank.&lt;br /&gt;
If the first pair(1,1) is to the left of the second pair(3,2), we immediately know that the second elements of the first pair(1) is less than the second element of the second pair(2), since we've sorted them by the second coordinate.&lt;br /&gt;
We then have this pair of elements can have Bridge built together if and only if the first element of the first pair(1) is less than the first element of the second pair(3).&lt;/p&gt;
&lt;p&gt;Consequently, if we want to find a set of Bridges that can be built together, we're looking for an Increasing Sub-Sequence of the Cities in Above Bank, since in that case both the first and second elements of the pairs are increasing as we move from the left to the right.&lt;/p&gt;
&lt;p&gt;Finding the longest increasing subsequence then solves this problem.&lt;/p&gt;
&lt;p&gt;Complexity:&lt;br /&gt;
Sort the pairs by their Below Bank = O(N log N)&lt;br /&gt;
Find the LIS in O(N log N)&lt;br /&gt;
So, this is an O(N log N) solution.&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Jan 2015 05:07:25 -0800</pubDate>
        <link>/algos/2015/01/01/constructing-bridges.html</link>
        <guid isPermaLink="true">/algos/2015/01/01/constructing-bridges.html</guid>
        
        
        <category>Algos</category>
        
      </item>
    
      <item>
        <title>Design a Tiny URl Service</title>
        <description>&lt;p&gt;Redirect Part:&lt;/p&gt;
&lt;p&gt;When you click on a link of any tiny url, an HTTP Request is sent to their server with the full URL, like http // bit.ly / b9 (not a real one).&lt;/p&gt;
&lt;p&gt;They read the path part (here b9), which maps to their Database.&lt;/p&gt;
&lt;p&gt;In the Database, they find the real URL. Then they issue a redirect, which is a HTTP 302 response and the target URL in the header.&lt;/p&gt;
&lt;p&gt;Encoding Part:&lt;/p&gt;
&lt;p&gt;One of the most popular URL shortening services simply take the ID in the database of the URL and then convert it to Base 62[a-zA-Z0-9].&lt;/p&gt;
&lt;p&gt;import static org.testing.AssertJUnit.assertEquals ;&lt;/p&gt;
&lt;p&gt;public class TinyURL {&lt;br /&gt;
private static final String ALPHABET_MAP = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot; ;&lt;br /&gt;
private static final int BASE = ALPHABET_MAP.length() ;&lt;/p&gt;
&lt;p&gt;public static String encode ( int IndexNum ) {&lt;br /&gt;
StringBuilder sb = new StringBuilder() ;&lt;/p&gt;
&lt;p&gt;while ( IndexNum &amp;gt; 0 ) {&lt;br /&gt;
sb.append ( ALPHABET_MAP.charAt ( IndexNum % BASE ) ) ;&lt;br /&gt;
IndexNum /= BASE ;&lt;br /&gt;
}&lt;br /&gt;
return sb.reverse().toString() ;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;public static int decode ( String str ) {&lt;br /&gt;
int Num = 0 ;&lt;/p&gt;
&lt;p&gt;for ( int i = 0, len = str.length(); i &amp;lt; len; i++ ) {&lt;br /&gt;
Num = Num * BASE + ALPHABET_MAP.indexOf ( str.charAt(i) ) ;&lt;br /&gt;
}&lt;br /&gt;
return Num ;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;public static void main ( String[] args ) {&lt;br /&gt;
//System.out.println ( &quot;Encoding for 123 is &quot; + encode(123) ) ;&lt;br /&gt;
//System.out.println ( &quot;Decoding for b9 is &quot; + decode (&quot;b9&quot; ) ) ;&lt;/p&gt;
&lt;p&gt;assertEquals ( &quot;b9&quot;, encode(123) ) ;&lt;br /&gt;
assertEquals ( 123, decode(&quot;b9&quot;) ) ;&lt;br /&gt;
}&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;I think this is more of a design question than a coding one.&lt;/p&gt;
&lt;p&gt;We can think about&lt;br /&gt;
- reducing the response time of the server&lt;br /&gt;
---- by using a distributed system to share the load based on geography&lt;br /&gt;
---- by using a central server but many caching servers at various geographical locations&lt;br /&gt;
---- what would be the right database design&lt;/p&gt;
&lt;p&gt;- reducing the storage space&lt;br /&gt;
---- database design&lt;/p&gt;
&lt;p&gt;- backup and failover&lt;/p&gt;
&lt;p&gt;- security issues&lt;br /&gt;
---- prevent people from creating links to ---whatever---&lt;/p&gt;
&lt;p&gt;- handling old/obsolete urls&lt;br /&gt;
---- may be, while creating the url we can say to the user that it will be deleted if the url is never used for more than say 3 years&lt;br /&gt;
---- may be allow the user to login and delete unused ones&lt;/p&gt;
&lt;p&gt;- how a company like bit.ly is going to make profit out of this service! how can that be improved&lt;/p&gt;
&lt;p&gt;- user friendly things&lt;br /&gt;
---- browser plugins to speed up creating links (youtube sharing has an option to create short urls)&lt;br /&gt;
---- giving report to user about the usage statistics&lt;br /&gt;
---- mobile app to create urls quickly&lt;/p&gt;
&lt;p&gt;.....&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Jan 2015 05:04:54 -0800</pubDate>
        <link>/design/2015/01/01/design-a-tiny-url-service.html</link>
        <guid isPermaLink="true">/design/2015/01/01/design-a-tiny-url-service.html</guid>
        
        
        <category>Design</category>
        
      </item>
    
      <item>
        <title>Creating an Array of Objects</title>
        <description>&lt;p&gt;I have a class A for example -&lt;/p&gt;
&lt;p&gt;A[] arr = new A[4];&lt;br /&gt;
But this is only creating pointers (references) to A and not 4 objects. Is this correct? I see that when I try to access functions/variables in the objects created I get a null pointer exception. To be able to manipulate/access the objects I had to do this --&lt;/p&gt;
&lt;p&gt;A[] arr = new A[4];&lt;br /&gt;
for( int i=0; i&amp;lt;4; i++ )&lt;br /&gt;
    arr[i] = new A();&lt;/p&gt;
&lt;p&gt;I find this odd because in C++ you just say new A[4] and it creates the four objects.&lt;/p&gt;
&lt;p&gt;This is correct.&lt;/p&gt;
&lt;p&gt;A[] a = new A[4];&lt;br /&gt;
creates 4 A variables, similar to doing this&lt;/p&gt;
&lt;p&gt;A a1;&lt;br /&gt;
A a2;&lt;br /&gt;
A a3;&lt;br /&gt;
A a4;&lt;br /&gt;
now you couldn&amp;#039;t do a1.someMethod() without allocating a1 as&lt;/p&gt;
&lt;p&gt;a1 = new A();&lt;br /&gt;
similarly, with the array you need to do&lt;/p&gt;
&lt;p&gt;a[0] = new A();&lt;br /&gt;
before using it.&lt;/p&gt;
&lt;p&gt;The reason int works, but MyClass doesn&amp;#039;t:&lt;/p&gt;
&lt;p&gt;From here:&lt;/p&gt;
&lt;p&gt;Data Type               Default Value (for fields)&lt;br /&gt;
byte                    0&lt;br /&gt;
short                   0&lt;br /&gt;
int                     0&lt;br /&gt;
long                    0L&lt;br /&gt;
float                   0.0f&lt;br /&gt;
double                  0.0d&lt;br /&gt;
char                    &amp;#039;\u0000&amp;#039;&lt;br /&gt;
String (or any object)  null&lt;br /&gt;
boolean                 false&lt;br /&gt;
When you initialize an array, all elements take on the default value.&lt;/p&gt;
&lt;p&gt;So, when you initialize an int[], all elements are 0, so no problem using that or assigning a new value to it.&lt;/p&gt;
&lt;p&gt;But, when you initialize an MyClass[], all elements are null, which is a problem when you try to access a member of one of the elements.&lt;/p&gt;
&lt;p&gt;If you don&amp;#039;t know why accessing a null object&amp;#039;s members won&amp;#039;t work, you probably need to take 2 steps back and read a Java book.&lt;/p&gt;
&lt;p&gt;Additional Note:&lt;/p&gt;
&lt;p&gt;Technically, this:&lt;/p&gt;
&lt;p&gt;int[] foo = new int[1];&lt;br /&gt;
foo[0] = 0;&lt;br /&gt;
is actually more like this:&lt;/p&gt;
&lt;p&gt;MyClass[] foo = new MyClass[10];&lt;br /&gt;
foo[0] = new MyClass();&lt;br /&gt;
not:&lt;/p&gt;
&lt;p&gt;MyClass[] foo = new MyClass[10];&lt;br /&gt;
foo[0].bar = 0;&lt;br /&gt;
since you&amp;#039;re assigning a new value to an element, rather than accessing a member of an element.&lt;/p&gt;
&lt;p&gt;No enclosing instance of type Test is accessible:&lt;/p&gt;
&lt;p&gt;The other answers cover that pretty well, and here are 3 related questions:&lt;/p&gt;
&lt;p&gt;No enclosing instance of type is accessible.&lt;/p&gt;
&lt;p&gt;No enclosing instance of type Server is accessible&lt;/p&gt;
&lt;p&gt;&amp;quot;No enclosing instance of type&amp;quot; error while calling method from another class in Android&lt;/p&gt;
</description>
        <pubDate>Wed, 19 Nov 2014 08:11:12 -0800</pubDate>
        <link>/java/2014/11/19/creating-an-array-of-objects.html</link>
        <guid isPermaLink="true">/java/2014/11/19/creating-an-array-of-objects.html</guid>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>[ALGO] Median of Integer Stream</title>
        <description>&lt;div id=&quot;stcpDiv&quot;&gt;
&lt;p&gt;Given a stream of unsorted integers, find the median element in sorted order at any given time. So, we will be receiving a continuous stream of numbers in some random order and we don’t know the stream length in advance. Write a function that finds the median of the already received numbers efficiently at any time. We will be asked to find the median multiple times. Just to recall, median is the middle element in an odd length sorted array, and in the even case it’s the average of the middle elements.&lt;/p&gt;
&lt;p&gt;This is a data structure question. We will insert the received numbers into such a data structure that we’ll be able to find the median very efficiently. Let’s analyse the possible options.&lt;/p&gt;
&lt;p&gt;We can insert the integers to an unsorted array, so we’ll just append the numbers to the array one by one as we receive. Insertion complexity is O(1) but finding the median will take O(N) time, if we use the &lt;a href=&quot;http://www.ardendertat.com/2011/10/27/programming-interview-questions-10-kth-largest-element-in-array/&quot;&gt;Median of Medians&lt;/a&gt; algorithm that I described in my previous post. However, our goal is to find the median most efficiently, we don’t care that much about insertion performance. But this algorithm does the exact opposite, so unsorted array is not a feasible solution.&lt;/p&gt;
&lt;p&gt;What about using a sorted array? We can find the position to insert the received number in O(logN) time using binary search. And at any time if we’re asked for the median we can just return the middle element if the array length is odd, or the average of middle elements if the length is even. This can be done in O(1) time, which is exactly what we’re looking for. But there’s a major drawback of using a sorted array. To keep the array sorted after inserting an element, we may need to shift the elements to the right, which will take O(N) time. So, even if finding the position to insert the number takes O(logN) time, the overall insertion complexity is O(N) due to shifting. But finding the median is still extremely efficient, constant time. However, linear time insertion is pretty inefficient and we would prefer a better performance.&lt;/p&gt;
&lt;p&gt;Let’s try linked lists. First unsorted linked list. Insertion is O(1), we can insert either to the head or tail but we suffer from the same problem of unsorted array. Finding the median is O(N). What if we keep the linked list sorted? We can find the median in O(1) time if we keep track of the middle elements. Insertion to a particular location is also O(1) in any linked list, so it seems great thus far. But, finding the right location to insert is not O(logN) as in sorted array, it’s instead O(N) because we can’t perform binary search in a linked list even if it is sorted. So, using a sorted linked list doesn’t worth the effort, insertion is O(N) and finding median is O(1), same as the sorted array. In sorted array insertion is linear due to shifting, here it’s linear because we can’t do binary search in a linked list. This is a very fundamental data structure knowledge that we should keep at the top of our heads all the time.&lt;/p&gt;
&lt;p&gt;Using a stack or queue wouldn’t help as well. Insertion would be O(1) but finding the median would be O(N), very inefficient.&lt;/p&gt;
&lt;p&gt;What if we use trees? Let’s use a binary search tree with additional information at each node, number of children on the left and right subtrees. We also keep the number of total nodes in the tree. Using this additional information we can find the median in O(logN) time, taking the appropriate branch in the tree based on number of children on the left and right of the current node. However, the insertion complexity is O(N) because a standard binary search tree can degenerate into a linked list if we happen to receive the numbers in sorted order.&lt;/p&gt;
&lt;p&gt;So, let’s use a balanced binary search tree to avoid worst case behaviour of standard binary search trees. In a height balanced binary search tree (i.e. AVL tree) the balance factor is the difference between the heights of left and right subtrees. A node with balance factor 0, +1, or -1 is considered to be balanced. However, in our tree the balance factor won’t be height, it is the number of nodes in the left subtree minus the number of nodes in the right subtree. And only the nodes with balance factor of +1 or 0 are considered to be balanced. So, the number of nodes on the left subtree is either equal to or 1 more than the number of nodes on the right subtree, but not less. If we ensure this balance factor on every node in the tree, then the root of the tree is the median, if the number of elements is odd. In the even case, the median is the average of the root and its inorder successor, which is the leftmost descendent of its right subtree. So, complexity of insertion maintaining balance condition is O(logN) and find median operation is O(1) assuming we calculate the inorder successor of the root at every insertion if the number of nodes is even. Insertion and balancing is very similar to AVL trees. Instead of updating the heights, we update the number of nodes information.&lt;/p&gt;
&lt;p&gt;Balanced binary search trees seem to be the most optimal solution, insertion is O(logN) and find median is O(1). Can we do better? We can achieve the same complexity with a simpler and more elegant solution. We will use 2 heaps simultaneously, a max-heap and a min-heap with 2 requirements. The first requirement is that the max-heap contains the smallest half of the numbers and min-heap contains the largest half. So, the numbers in max-heap are always less than or equal to the numbers in min-heap. Let’s call this the order requirement. The second requirement is that, the number of elements in max-heap is either equal to or 1 more than the number of elements in the min-heap. So, if we received 2N elements (even) up to now, max-heap and min-heap will both contain N elements. Otherwise, if we have received 2N+1 elements (odd), max-heap will contain N+1 and min-heap N. Let’s call this the size requirement.&lt;/p&gt;
&lt;p&gt;The heaps are constructed considering the two requirements above. Then once we’re asked for the median, if the total number of received elements is odd, the median is the root of the max-heap. If it’s even, then the median is the average of the roots of the max-heap and min-heap. Let’s now analyse why this approach works, and how we construct the heaps.&lt;/p&gt;
&lt;p&gt;We will have two methods, insert a new received number to the heaps and find median. The insertion procedure takes the two requirements into account, and it’s executed every time we receive a new element. We take two different approaches depending on whether the total number of elements is even or odd before insertion.&lt;/p&gt;
&lt;p&gt;Let’s first analyze the size requirement during insertion. In both cases we insert the new element to the max-heap, but perform different actions afterwards. In the first case, if the total number of elements in the heaps is even before insertion, then there are N elements both in max-heap and min-heap because of the size requirement. After inserting the new element to the max-heap, it contains N+1 elements but this doesn’t violate the size requirement. Max-heap can contain 1 more element than min-heap. In the second case, if the number of elements is odd before insertion, then there are N+1 elements in max-heap and N in min-heap. After we insert the new element to the max-heap, it contains N+2 elements. But this violates the size constraint, max-heap can contain at most 1 more element than min-heap. So we pop an element from max-heap and push it to min-heap. The details will be described soon.&lt;/p&gt;
&lt;p&gt;Now let’s analyse the order requirement. This requirement forces every element in the max-heap to be less than or equal to all the elements in min-heap. So the max-heap contains the smaller half of the numbers and the min-heap contains the larger half. Note that by design the root of the max-heap is the maximum of the lower half, and root of the min-heap is the minimum of the upper half. Keeping these in mind, we again take two different actions depending on whether the total number of elements is even or odd before insertion. In the even case we just inserted the new element to the max-heap. If the new element is less than all the elements in the min-heap, then the order constraint is satisfied and we’re done. We can perform this check by comparing the new element to the root of the min-heap in O(1) time since the root of the min-heap is the minimum. But if the new element is larger than the root of min-heap then we should exchange those elements to satisfy the order requirement. Note that in this case the root of the max-heap is the new element. So we pop the the root of min-heap and insert it to max-heap. Also pop the root of max-heap and insert it to min-heap. In second case, where the total number of elements before insertion is odd, we inserted the new element to max-heap, then we popped an element and pushed it to the min-heap. To satisfy the order constraint, we pop the maximum element of the max-heap, the root, and insert it to the min-heap. Insertion complexity is O(logN), which is the insertion complexity of a heap.&lt;/p&gt;
&lt;p&gt;That is exactly how the insertion procedure works. We ensured that both size and order requirements are satisfied during insertion. Find median function works as follows. At any time we will be queried for the median element. If the total number of elements at that time is odd, then the median is the root of the max-heap. Let’s visualize this with an example. Assume that we have received 7 elements up to now, so the median is the 4th number in sorted order. Currently, max-heap contains 4 smallest elements and min-heap contains 3 largest because of the requirements described above. And since the root of the max-heap is the maximum of the smallest four elements, it’s the 4th element in sorted order, which is the median. Else if the total number of elements is even, then the median is the average of the roots of max-heap and min-heap. Let’s say we have 8 elements, so the median is the average of 4th and 5th elements in sorted order. Currently, both the max-heap and min-heap contain 4 numbers. Root of the max-heap is the maximum of the smallest numbers, which is 4th in sorted order. And root of the min-heap is the minimum of the largest numbers, which is 5th in sorted order. So, the median is the average of the roots. In both cases we can find the median in O(1) time because we only access the roots of the heaps, neither insertion nor removal is performed. Therefore, overall this solution provides O(1) find heap and O(logN) insert.&lt;/p&gt;
&lt;p&gt;A code is worth a thousand words, here is the code of the 2-heaps solution. As you can see, it’s much less complicated than it’s described. We can use the heapq module in python, which provides an implementation of min-heap only. But we need a max-heap as well, so we can make a min-heap behave like a max-heap by multiplying the number to be inserted by -1 and then inserting. So, every time we insert or access an element from the max-heap, we multiply the value by -1 to get the original number:&lt;/p&gt;
&lt;div class=&quot;wp_syntax&quot;&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;pre class=&quot;python&quot;&gt;class streamMedian:
    def __init__(self):
        self.minHeap, self.maxHeap = [], []
        self.N=0
 
    def insert(self, num):
        if self.N%2==0:
            heapq.heappush(self.maxHeap, -1*num)
            self.N+=1
            if len(self.minHeap)==0:
                return
            if -1*self.maxHeap[0]&amp;gt;self.minHeap[0]:
                toMin=-1*heapq.heappop(self.maxHeap)
                toMax=heapq.heappop(self.minHeap)
                heapq.heappush(self.maxHeap, -1*toMax)
                heapq.heappush(self.minHeap, toMin)
        else:
            toMin=-1*heapq.heappushpop(self.maxHeap, -1*num)
            heapq.heappush(self.minHeap, toMin)
            self.N+=1
 
    def getMedian(self):
        if self.N%2==0:
            return (-1*self.maxHeap[0]+self.minHeap[0])/2.0
        else:
            return -1*self.maxHeap[0]&lt;/pre&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;We have a class streamMedian, and every time we receive an element, insert function is called. The median is returned using the getMedian function.&lt;/p&gt;
&lt;p&gt;This is a great interview question that tests data structure fundamentals in a subtle way.&lt;/p&gt;
&lt;p&gt;- See more at: http://www.ardendertat.com/2011/11/03/programming-interview-questions-13-median-of-integer-stream/#sthash.dvIFZG2G.dpuf&lt;/p&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 08 Oct 2014 09:38:00 -0700</pubDate>
        <link>/algos/2014/10/08/algo-median-of-integer-stream.html</link>
        <guid isPermaLink="true">/algos/2014/10/08/algo-median-of-integer-stream.html</guid>
        
        
        <category>Algos</category>
        
      </item>
    
      <item>
        <title>How to make a method thread-safe in Java?</title>
        <description>&lt;p&gt;Interview Question:&lt;/p&gt;
&lt;p&gt;Is the following method thread-safe? How to make it thread-safe?&lt;/p&gt;
&lt;div class=&quot;wp_syntax&quot;&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;pre class=&quot;java&quot;&gt;class MyCounter {
	private static int counter = 0;
 
	public static int getCount() {
		return counter++;
	}
}&lt;/pre&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;This post explains a general interview question that has been asked by Google and a lot of companies. It's low-level and not about how to design concurrent program.&lt;/p&gt;
&lt;p&gt;First of all, the answer is NO. The method is not thread-safe, because the &lt;em&gt;counter++&lt;/em&gt; operation is not atomic, which means it consists more than one atomic operations. In this case, one is accessing value and the other is increasing the value by one.&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-11967&quot; src=&quot;/assets/thread-safe-method1.png&quot; alt=&quot;thread-safe method&quot; width=&quot;400&quot; height=&quot;280&quot; /&gt;&lt;/p&gt;
&lt;p&gt;When Thread 1 accesses the method at t1, Thread 2 may not be done with the method. So the value returned to Thread 1 is the value that has not been increased.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Make a method thread-safe - Method 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Adding synchronized to this method will makes it thread-safe. When &lt;em&gt;synchronized&lt;/em&gt; is added to a static method, the &lt;em&gt;Class&lt;/em&gt; object is the object which is locked.&lt;/p&gt;
&lt;p&gt;Is marking it synchronized enough? The answer is YES.&lt;/p&gt;
&lt;div class=&quot;wp_syntax&quot;&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;pre class=&quot;java&quot;&gt;class MyCounter {
	private static int counter = 0;
 
	public static synchronized int getCount() {
		return counter++;
	}
}&lt;/pre&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;If the method is not static, then adding &lt;em&gt;synchronized&lt;/em&gt; keyword willsynchronize the instance of the class, not the &lt;em&gt;Class&lt;/em&gt; object.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Make a method thread-safe - Method 2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In this particular counter example, we actually can make &lt;em&gt;count++&lt;/em&gt; atomic by using AtomicInteger from the package &quot;java.util.concurrent.atomic&quot;.&lt;/p&gt;
&lt;div class=&quot;wp_syntax&quot;&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;pre class=&quot;java&quot;&gt;import java.util.concurrent.atomic.AtomicInteger;
 
public class MyCounter {
	private static AtomicInteger counter = new AtomicInteger(0);
 
	public static int getCount() {
		return counter.getAndIncrement();
	}
}&lt;/pre&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Some other useful facts about thread-safe&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Local variables are thread safe in Java.&lt;/p&gt;
&lt;p&gt;Each thread has its own stack. Two different threads never shares the same stack. All local variables defined in a method will be allocated memory in stack. As soon as method execution is completed by the current thread, stack frame will be removed.&lt;/p&gt;
&lt;p&gt;http://www.programcreek.com/2014/02/how-to-make-a-method-thread-safe-in-java/&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Sep 2014 21:19:59 -0700</pubDate>
        <link>/java/2014/09/13/how-to-make-a-method-thread-safe-in-java-2.html</link>
        <guid isPermaLink="true">/java/2014/09/13/how-to-make-a-method-thread-safe-in-java-2.html</guid>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>[TREE] Inorder successor and predecessor of a BST without parent pointer</title>
        <description>&lt;p&gt;Problem:&lt;br /&gt;
Find inorder successor/predecessor of given node in binary search tree.&lt;/p&gt;
&lt;p&gt;In-order successor of a node is the node which will come after the given node in in-order traversal of binary search tree. In other words, it would be the next larger element in BST.&lt;/p&gt;
&lt;p&gt;There are four cases:&lt;/p&gt;
&lt;p&gt;1. If there is a right child of the given node. In this case the smallest element in the right sub tree would be the in-order successor.&lt;br /&gt;
2. If node does not have right sub tree and if last turn was right, then the node where we took the last left turn will be the in-order successor.&lt;br /&gt;
3. If node does not have right sub tree and if last turn was left turn, parent of the node is inorder successor.&lt;br /&gt;
4. If the node is the right most node, then there is no in-order successor.&lt;/p&gt;
&lt;p&gt;It is clear from the analysis that we need to change the candidate only when we are moving towards left and not when moving right.&lt;/p&gt;
&lt;p&gt;Algorithm&lt;br /&gt;
1. Start with root.&lt;br /&gt;
2. If the node is given has less than root, then search on left side and update successor.&lt;br /&gt;
3. If the node is greater than root, then search in right part, don't update successor.&lt;br /&gt;
4. If we find the node and if the node has right sub tree, then the minimum node on the right sub tree of node is the in-order successor.&lt;br /&gt;
5. Return successor&lt;/p&gt;
&lt;p&gt;The Algorithm is divided into two cases on the basis of right subtree of the input node being empty or not.&lt;/p&gt;
&lt;p&gt;Input: node, root // node is the node whose Inorder successor is needed.&lt;br /&gt;
output: succ // succ is Inorder successor of node.&lt;/p&gt;
&lt;p&gt;1) If right subtree of node is not NULL, then succ lies in right subtree. Do following.&lt;br /&gt;
Go to right subtree and return the node with minimum key value in right subtree.&lt;br /&gt;
2) If right sbtree of node is NULL, then start from root and us search like technique. Do following.&lt;br /&gt;
Travel down the tree, if a node’s data is greater than root’s data then go right side, otherwise go to left side.&lt;/p&gt;
&lt;p&gt;struct node * inOrderSuccessor(struct node *root, struct node *n)&lt;br /&gt;
{&lt;br /&gt;
    // step 1 of the above algorithm&lt;br /&gt;
    if( n-&amp;gt;right != NULL )&lt;br /&gt;
        return minValue(n-&amp;gt;right);&lt;/p&gt;
&lt;p&gt;    struct node *succ = NULL;&lt;/p&gt;
&lt;p&gt;    // Start from root and search for successor down the tree&lt;br /&gt;
    while (root != NULL)&lt;br /&gt;
    {&lt;br /&gt;
        if (n-&amp;gt;data data)&lt;br /&gt;
        {&lt;br /&gt;
            succ = root;&lt;br /&gt;
            root = root-&amp;gt;left;&lt;br /&gt;
        }&lt;br /&gt;
        else if (n-&amp;gt;data &amp;gt; root-&amp;gt;data)&lt;br /&gt;
            root = root-&amp;gt;right;&lt;br /&gt;
        else&lt;br /&gt;
           break;&lt;br /&gt;
    }&lt;/p&gt;
&lt;p&gt;    return succ;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;OR&lt;br /&gt;
Node * find_minimum(Node *root){&lt;br /&gt;
        if(!root)&lt;br /&gt;
                return NULL;&lt;/p&gt;
&lt;p&gt;        while(root-&amp;gt;left){&lt;br /&gt;
                root = root-&amp;gt;left;&lt;/p&gt;
&lt;p&gt;        }&lt;br /&gt;
        return root;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;Node *inorder_success(Node *root, int K){&lt;/p&gt;
&lt;p&gt;        Node * successor = NULL;&lt;br /&gt;
        Node *current  = root;&lt;br /&gt;
        if(!root)&lt;br /&gt;
                return NULL;&lt;/p&gt;
&lt;p&gt;        while(current-&amp;gt;value != K){&lt;br /&gt;
                if(current-&amp;gt;value &amp;gt;K){&lt;br /&gt;
                        successor = current;&lt;br /&gt;
                        current= current-&amp;gt;left;&lt;br /&gt;
                }&lt;br /&gt;
                else&lt;br /&gt;
                        current = current-&amp;gt;right;&lt;br /&gt;
        }&lt;br /&gt;
        if(current &amp;amp;&amp;amp; current-&amp;gt;right){&lt;br /&gt;
                successor = find_minimum(current-&amp;gt;right);&lt;br /&gt;
        }&lt;/p&gt;
&lt;p&gt;        return successor;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;Time Complexity: O(h) where h is height of tree.&lt;br /&gt;
Complexity of this algorithm will be O(logN) in almost balanced binary tree. If tree is skewed, then we have worst case complexity of O(N).&lt;/p&gt;
&lt;p&gt;Inorder Predecessor:&lt;br /&gt;
Case 1: Node has left sub  tree.&lt;br /&gt;
In this case the right most node in the left sub-tree would be the in-order predecessor.&lt;/p&gt;
&lt;p&gt;Case 2: Node has no left sub-tree.&lt;br /&gt;
In this case in-order predecessor will be the node where we took the latest right turn.&lt;/p&gt;
&lt;p&gt;Case 3 : Node is left most node of BST.&lt;br /&gt;
There is no in-order predecessor in this case and In this case there won't  be any right turn.i.e. return NULL&lt;/p&gt;
&lt;p&gt;Node * find_maximum(Node *root){&lt;br /&gt;
        if(!root)&lt;br /&gt;
                return NULL;&lt;/p&gt;
&lt;p&gt;        while(root-&amp;gt;right){&lt;br /&gt;
                root = root-&amp;gt;right;&lt;/p&gt;
&lt;p&gt;        }&lt;br /&gt;
        return root;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;Node *inorder_preced(Node *root, int K){&lt;/p&gt;
&lt;p&gt;        Node * successor = NULL;&lt;br /&gt;
        Node *current  = root;&lt;br /&gt;
        if(!root)&lt;br /&gt;
                return NULL;&lt;/p&gt;
&lt;p&gt;        while(current &amp;amp;&amp;amp; current-&amp;gt;value != K){&lt;br /&gt;
                if(current-&amp;gt;value &amp;gt;K){&lt;br /&gt;
                        current= current-&amp;gt;left;&lt;br /&gt;
                }&lt;br /&gt;
                else{&lt;br /&gt;
                        successor = current;&lt;br /&gt;
                        current = current-&amp;gt;right;&lt;br /&gt;
                }&lt;br /&gt;
        }&lt;br /&gt;
        if(current &amp;amp;&amp;amp; current-&amp;gt;left){&lt;br /&gt;
                successor = find_maximum(current-&amp;gt;left);&lt;br /&gt;
        }&lt;/p&gt;
&lt;p&gt;        return successor;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;Complexity analysis&lt;br /&gt;
Complexity of finding in-order predecessor would be same as successor i.e. O(logN).&lt;/p&gt;
&lt;p&gt;PS&lt;br /&gt;
Method 1 (Uses Parent Pointer)&lt;br /&gt;
In this method, we assume that every node has parent pointer.&lt;/p&gt;
&lt;p&gt;The Algorithm is divided into two cases on the basis of right subtree of the input node being empty or not.&lt;/p&gt;
&lt;p&gt;Input: node, root // node is the node whose Inorder successor is needed.&lt;br /&gt;
output: succ // succ is Inorder successor of node.&lt;/p&gt;
&lt;p&gt;1) If right subtree of node is not NULL, then succ lies in right subtree. Do following.&lt;br /&gt;
Go to right subtree and return the node with minimum key value in right subtree.&lt;br /&gt;
2) If right sbtree of node is NULL, then succ is one of the ancestors. Do following.&lt;br /&gt;
Travel up using the parent pointer until you see a node which is left child of it’s parent. The parent of such a node is the succ.&lt;/p&gt;
&lt;p&gt;Implementation&lt;br /&gt;
Note that the function to find InOrder Successor is highlighted (with gray background) in below code.&lt;/p&gt;
&lt;p&gt;#include&lt;br /&gt;
#include &lt;/p&gt;
&lt;p&gt;/* A binary tree node has data, pointer to left child&lt;br /&gt;
   and a pointer to right child */&lt;br /&gt;
struct node&lt;br /&gt;
{&lt;br /&gt;
    int data;&lt;br /&gt;
    struct node* left;&lt;br /&gt;
    struct node* right;&lt;br /&gt;
    struct node* parent;&lt;br /&gt;
};&lt;/p&gt;
&lt;p&gt;struct node * minValue(struct node* node); &lt;/p&gt;
&lt;p&gt;struct node * inOrderSuccessor(struct node *root, struct node *n)&lt;br /&gt;
{&lt;br /&gt;
  // step 1 of the above algorithm&lt;br /&gt;
  if( n-&amp;gt;right != NULL )&lt;br /&gt;
    return minValue(n-&amp;gt;right);&lt;/p&gt;
&lt;p&gt;  // step 2 of the above algorithm&lt;br /&gt;
  struct node *p = n-&amp;gt;parent;&lt;br /&gt;
  while(p != NULL &amp;amp;&amp;amp; n == p-&amp;gt;right)&lt;br /&gt;
  {&lt;br /&gt;
     n = p;&lt;br /&gt;
     p = p-&amp;gt;parent;&lt;br /&gt;
  }&lt;br /&gt;
  return p;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;/* Given a non-empty binary search tree, return the minimum data&lt;br /&gt;
    value found in that tree. Note that the entire tree does not need&lt;br /&gt;
    to be searched. */&lt;br /&gt;
struct node * minValue(struct node* node) {&lt;br /&gt;
  struct node* current = node;&lt;/p&gt;
&lt;p&gt;  /* loop down to find the leftmost leaf */&lt;br /&gt;
  while (current-&amp;gt;left != NULL) {&lt;br /&gt;
    current = current-&amp;gt;left;&lt;br /&gt;
  }&lt;br /&gt;
  return current;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;-------------------------------------------------------------------------------------------------------&lt;br /&gt;
Here is a non-recursive version of finding the successor.  There are two cases: (i) the right child of  node is not NULL. In this case, we can find the successor by finding the minimum element of the right substree. (ii) If the right child of node is NULL, the successor must either be NULL, or the lowest node on the path from root to node whose value is larger than node's value.&lt;/p&gt;
&lt;p&gt;/*&lt;br /&gt;
 * We assume that 'node' is in the tree&lt;br /&gt;
 */&lt;br /&gt;
Node * find_successor(Node * root, Node * node)&lt;br /&gt;
{&lt;br /&gt;
    Node * y = root, * c = NULL;&lt;/p&gt;
&lt;p&gt;    if (node-&amp;gt;right != NULL){&lt;br /&gt;
       y = node-&amp;gt;right;&lt;br /&gt;
       while (y-&amp;gt;left != NULL) y = y-&amp;gt;left;&lt;br /&gt;
       return y;&lt;br /&gt;
    }&lt;/p&gt;
&lt;p&gt;    while ( y != node &amp;amp;&amp;amp; y != NULL ){&lt;br /&gt;
      if ( node-&amp;gt;data data ){&lt;br /&gt;
         c = y;&lt;br /&gt;
         y = y-&amp;gt;left;&lt;br /&gt;
      }&lt;br /&gt;
      else{&lt;br /&gt;
         y = y-&amp;gt;right;&lt;br /&gt;
      }&lt;br /&gt;
    }&lt;br /&gt;
    return c;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;Node * find_predecessor(Node * root, Node * node)&lt;br /&gt;
{&lt;br /&gt;
    Node * y = root, *c = NULL;&lt;br /&gt;
    if (node-&amp;gt;left != NULL){&lt;br /&gt;
       y = node-&amp;gt;left;&lt;br /&gt;
       while (y-&amp;gt;right != NULL) y = y-&amp;gt;right;&lt;br /&gt;
       return y;&lt;br /&gt;
    }&lt;/p&gt;
&lt;p&gt;    while ( y != node ){&lt;br /&gt;
       if (node-&amp;gt;data data){&lt;br /&gt;
         y = y-&amp;gt;left;&lt;br /&gt;
       }&lt;br /&gt;
       else {&lt;br /&gt;
         c = y;&lt;br /&gt;
         y = y-&amp;gt;right;&lt;br /&gt;
       }&lt;br /&gt;
    }&lt;br /&gt;
    return c;&lt;br /&gt;
}&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Mar 2014 09:50:24 -0700</pubDate>
        <link>/algos/2014/03/24/tree-inorder-successor-and-predecessor-of-a-bst-without-parent-pointer.html</link>
        <guid isPermaLink="true">/algos/2014/03/24/tree-inorder-successor-and-predecessor-of-a-bst-without-parent-pointer.html</guid>
        
        
        <category>Algos</category>
        
      </item>
    
      <item>
        <title>[ARRAY] Relocate arr[I] = arr[arr[I]]</title>
        <description>&lt;p&gt;WAP to modify the array such that arr[I] = arr[arr[I]].&lt;br /&gt;
Do this in place i.e. with out using additional memory. &lt;/p&gt;
&lt;p&gt;example : if a = {2,3,1,0}&lt;br /&gt;
o/p = a = {1,0,3,2} &lt;/p&gt;
&lt;p&gt;Note : The array contains 0 to n-1 integers.&lt;/p&gt;
&lt;p&gt;void relocate(int *arr,int size) {&lt;br /&gt;
	for(int i=0;i&amp;lt;size;i++) {&lt;br /&gt;
		arr[i] += (arr[arr[i]]%size)*size;&lt;br /&gt;
	}&lt;br /&gt;
	for(int i=0;i&amp;lt;size;i++) {&lt;br /&gt;
		arr[i] /= size;&lt;br /&gt;
	}&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;It is simple maths:&lt;/p&gt;
&lt;p&gt;(x + y*z)/z = y    provided x and y is less than z.&lt;br /&gt;
(x + y*z)%z = x    provided x and y is less than z.&lt;br /&gt;
This is the concept used here.&lt;br /&gt;
Example:&lt;br /&gt;
(3 + 4*5)/5 = 4&lt;br /&gt;
(3 + 4*5)%5 = 3&lt;/p&gt;
&lt;p&gt;arr[i] = arr[i] + arr[arr[i]]*size&lt;br /&gt;
so arr[i]/size = arr[arr[i]]&lt;/p&gt;
&lt;p&gt;In the code you see the author has used % below; this is done just to make sure arr[i] and arr[arr[i]] is less than size as explained earlier.&lt;br /&gt;
arr[i] += (arr[arr[i]]%size)*size;&lt;/p&gt;
&lt;p&gt;When he multiplies the arr[arr[i]] by size and add the current value to it, you get a new value. This new value can use division to get the final result or modulo to obtain the current value.&lt;br /&gt;
When he does the division, the current value(remainder) just falls off and you get the final value.&lt;/p&gt;
&lt;p&gt;In the first loop, I add (size * &amp;quot;OLD arr[arr[i]]&amp;quot;) to arr[i] so that, when doing integer division by size, I get old arr[arr[i]], when doing %size, I get old arr[i]. However I add arr[arr[i]]%size to get old arr[arr[i]], in case it was already modified in the loop. The second loop simply replaces each arr[i] with old arr[arr[i]], as mentioned above.&lt;/p&gt;
&lt;p&gt;FAQ:&lt;br /&gt;
Do we really need (arr[arr[i]] % size) why cant we directly put the arr[arr[i]] which i guess will yield the same result.since the values of array cannot be more than the size...&lt;br /&gt;
--- I think you need the %size because you can potentially retrieve the new final value from arr[arr[i]]. And that would mess up the calculation. You can try it with the input from the question:&lt;br /&gt;
{2,3,1,0} will become:&lt;br /&gt;
{1,0,3,6}&lt;/p&gt;
</description>
        <pubDate>Mon, 03 Mar 2014 02:58:36 -0800</pubDate>
        <link>/algos/2014/03/03/array-relocate-arri-arrarri.html</link>
        <guid isPermaLink="true">/algos/2014/03/03/array-relocate-arri-arrarri.html</guid>
        
        
        <category>Algos</category>
        
      </item>
    
      <item>
        <title>Melbourne --- AUSTRALIAN GRAND PRIX</title>
        <description>&lt;p&gt;
Why go?&lt;/p&gt;
&lt;p&gt;The Australian Grand Prix Corporation coined the phrase 'a great place for the race' and Melbourne is just that. Australia's second largest city is one of the most vibrant and cosmopolitan on earth, with plenty to do both day and night. The climate in late summer is perfect, the people are friendly and, to top it all, the Grand Prix is one of the most well organised of the year.&lt;/p&gt;
&lt;p&gt;&quot;Melburnians are sports-mad,&quot; says local hero Mark Webber. &quot;The climate allows for a very outdoor lifestyle, so people are always doing something.&quot;&lt;/p&gt;
&lt;p&gt;Albert Park staged a non-championship Grand Prix between 1956 and '58, but only in 1996 did it appear on the world championship calendar. Until 2005 the race had always been the season-opener, but that changed for 2006 due to the Commonwealth Games being staged in Melbourne until mid-March.&lt;/p&gt;
&lt;p&gt;&quot;You're totally spoilt for choice when it comes to restaurants, so you could spend the whole time eating if you wanted,&quot; adds Webber. &quot;I take a look at the Melbourne Cricket Ground and tootle down the Great Ocean Road, which is an easy drive away.&quot;&lt;/p&gt;
&lt;p&gt;Did you know? Melbourne is said to be the fox capital of the western world, with an estimated six foxes per square kilometre in the metropolitan area.&lt;br /&gt;
Transport&lt;/p&gt;
&lt;p&gt;International flights arrive at Melbourne's Tullamarine Airport, 22 kilometres north west of the city. A taxi from there to the city centre is inexpensive. Alternatively, there is a regular bus service.&lt;/p&gt;
&lt;p&gt;Melbourne's parks, beaches and open spaces make it pleasurable city to walk around. Everything is quite spread out, but the city's cheap and convenient tram system makes getting about easy. There are several stops near the Albert Park circuit, which is two kilometres south of the city centre.&lt;/p&gt;
&lt;p&gt;If hiring a car, don't forget to pay the automatic motorway toll, and have plenty of coins handy as most inner city parking is metered.&lt;br /&gt;
Useful tips&lt;/p&gt;
&lt;p&gt;Set in mown parkland, the circuit is easy to walk around. That makes general admission an appealing ticket to have on race day. But there are lots of grandstands too, particularly at the beginning and end of the lap, divided into three basic ticket prices. Remember to take sun cream and a hat. Even in March, the days are long and the rays are strong.&lt;br /&gt;
Book Tickets&lt;/p&gt;
&lt;p&gt;In the evenings, don't book early for dinner. Melbourne's bustling nightlife doesn't kick off until around 9pm, and don't go clubbing until gone midnight - unless you suffer from claustrophobia and like an empty dance floor...&lt;/p&gt;
&lt;p&gt;Another bit of advice - and one well worth heeding - comes direct from the state department's traffic agency, which has the following slogan visible at various points around Albert Park: 'If you drink and drive, you're a bl**dy idiot!'&lt;br /&gt;
Where to go?&lt;/p&gt;
&lt;p&gt;There's something for everyone in Melbourne, as you'd expect from a city known for being the arts, culinary and sporting capital of Australia. To name just a few daytime attractions: the Aquarium, the old Gaol, Melbourne Zoo, Melbourne Cricket Ground, the Ian Potter Centre and Chinatown.&lt;/p&gt;
&lt;p&gt;&quot;This might sound a bit weird,&quot; says Webber, &quot;but a lot of young Aussies are getting into lawn bowls. They have a few beers and have a good laugh doing that. Don't knock it until you've tried it!&quot;&lt;br /&gt;
Where to stay?&lt;/p&gt;
&lt;p&gt;Since the Grand Prix came to Albert Park, the south Melbourne area has benefited from a lot of regeneration and there are now plenty of places to stay within walking distance of the track.&lt;/p&gt;
&lt;p&gt;St Kilda is a popular destination for the F1 media because of its mix of street restaurants, clubs and stunning views of Port Phillip Bay. Drivers and senior team members tend to stay more centrally, usually at the Crown Towers.&lt;br /&gt;
Extended stay&lt;/p&gt;
&lt;p&gt;There are plenty of things to do in Victoria, but if you'd prefer to get away from it all, jump on a plane, head north and visit the Great Barrier Reef.&lt;/p&gt;
&lt;p&gt;&quot;Victoria is not my home state,&quot; says Webber, &quot;but I always fancy a road trip up the Great Ocean Road to check out some of the beaches. You've got to go to Lorne, Torquay or Bell's Beach, where they filmed the movie Point Break. If you plan to surf, that place isn't for boys, let me tell you. Elsewhere, I'd head to the snowfields to the north or to some of the vineyards.&quot;&lt;br /&gt;
Enthusiasts only&lt;/p&gt;
&lt;p&gt;Phillip Island, home of the Australian Motorcycle Grand Prix is 140 kilometres south east of Melbourne. The bikers are often testing at around the time of the Formula One Grand Prix, so you might get to see some action.&lt;/p&gt;
&lt;p&gt;For those in search of some Grand Prix nostalgia, go to Adelaide and drive the old Grand Prix track, which hosted the Australian race from 1985 to 1995.&lt;br /&gt;
Circuit address&lt;/p&gt;
&lt;p&gt;Albert Park&lt;br /&gt;
220 Albert Road&lt;br /&gt;
South Melbourne&lt;br /&gt;
Victoria 3205&lt;br /&gt;
Australia&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Feb 2014 22:48:16 -0800</pubDate>
        <link>/travel/2014/02/10/melbourne-australian-grand-prix.html</link>
        <guid isPermaLink="true">/travel/2014/02/10/melbourne-australian-grand-prix.html</guid>
        
        
        <category>Travel</category>
        
      </item>
    
  </channel>
</rss>
